// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// RibClient is the client API for Rib service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RibClient interface {
	// [brief]: Route Initialization operation.
	// [detail]: Initializes the client with default preferences and
	// response address format.
	//
	// Route initialization is mandatory to be called before invoking
	// any other RIB API's.
	//
	// Route initialization request contains the default address format to be set
	// and default preference values.
	//
	// Initialization API can be called multiple times and the default parameters
	// will be updated with the latest values from the initialization
	// request.
	//
	// Route initialization API returns the status of the initialization along
	// with the detailed text message and the number of routes present in RIB owned by
	// previous sessions of the given client ID.
	RouteInitialize(ctx context.Context, in *RouteInitializeRequest, opts ...grpc.CallOption) (*RouteInitializeResponse, error)
	// [brief]: Route clean up operation.
	// [detail]: RouteCleanup cleans all the routes added by the
	// particular client ID.
	// The API always returns the final status and the textual detailed message.
	RouteCleanup(ctx context.Context, in *RouteCleanupRequest, opts ...grpc.CallOption) (*RouteCleanupResponse, error)
	// [brief]: Route Add operation
	// [detail]: Add a static route to the routing table.
	// RouteAdd may be called multiple times for the same prefix to add
	// multiple paths with distinct cookie for the same destination.
	// If a matching route already exists in the given table, then an error
	// will be returned.
	// RouteUpdateRequest may contain from one to 1000 routes to be added.
	// If the request contains multiple routes, the routes will
	// be processed in the order given and the first error encountered will
	// cause the request to abort.
	// The API always returns the final status (success or first error
	// encountered) and the number of routes that were successfully created
	// prior to any error or full completion of the request.
	RouteAdd(ctx context.Context, in *RouteUpdateRequest, opts ...grpc.CallOption) (*RouteSetOperResponse, error)
	// [brief]: Route Modify operation
	// [detail]: Modify an existing programmed static route in the routing
	// table. For each route in the request, if the key is matched, the
	// matched route will be updated with the supplied route attributes.
	// If a matching route does not exist in the given table, then an error
	// will be returned.
	// RouteUpdateRequest may contain from one to 1000 routes to be modified.
	// If the request contains multiple routes, the routes will be processed
	// in the order given and the first error encountered will cause the
	// request to abort.
	// The API always returns the final status (success or first error
	// encountered) and the number of routes that were successfully modified
	// prior to any error or full completion of the request.
	RouteModify(ctx context.Context, in *RouteUpdateRequest, opts ...grpc.CallOption) (*RouteSetOperResponse, error)
	// [brief]: Route Update operation
	// [detail]: Create a new static route if a matching route does not exist,
	// OR modify an existing static route if it is already present in the
	// routing table.
	// RouteUpdateRequest may contain from one to 1000 routes to be added.
	// If the request contains multiple routes, the routes will be processed
	// in the order given and the first error encountered will cause the
	// request to abort.
	// The API always returns the final status (success or first error
	//  encountered) and the number of routes that were successfully modified
	// prior to any error or full completion of the request.
	RouteUpdate(ctx context.Context, in *RouteUpdateRequest, opts ...grpc.CallOption) (*RouteSetOperResponse, error)
	// [brief]: Route Delete operation
	// [detail]: Delete a static route from the routing table.
	// RouteDelete may be called multiple times for the same prefix
	// to delete multiple paths with distinct path_cookie for the same
	// destination. (NOTE: cookie support not yet implemented)
	// The request may contain from one to 1000 routes to be deleted.
	// If the request contains multiple routes, the routes will
	// be processed in the order given and the first error encountered will
	// cause the request to abort.
	// The API always returns the final status (success or first error
	// encountered) and the number of routes that were successfully modified
	// prior to any error or full completion of the request.
	RouteDelete(ctx context.Context, in *RouteDeleteRequest, opts ...grpc.CallOption) (*RouteDeleteResponse, error)
	// [brief]: Route Get operation
	// [detail]: Lookup a route from the routing table.
	//  Match fields that are not specified or that
	//  may match more than one route (e.g. a less-specific destination
	//  prefix) may result in multiple routes being returned in the replies.
	//  Responses are bulked for performance and the client can specify
	//  maximum number of route entries that JUNOS can send in one response
	//  message using route_count field. JUNOS may choose to pack less
	//  number of entries than that client has specified.
	//  Multiple route entries matching a given route prefix
	//  may be be counted as one (if its last one in the response) and may
	//  result in exceeding the specified route count.
	//  Replies are streamed until all match routes have been sent. The
	//  client will receive a final null message once all routes have
	//  been received.
	//  The server's walk of search results is not atomic so route changes
	//  during streaming and consumption of replies may or may not be
	//  reflected in the results.
	RouteGet(ctx context.Context, in *RouteGetRequest, opts ...grpc.CallOption) (Rib_RouteGetClient, error)
	// [brief]: Subscribe for the route entries of a table.
	// [detail]: When clients subscribe for a table all routes that passes
	// policy are streamed to the client. After this the routes that get added
	// or changed or deleted are streamed.
	// Clients can subscribe to more than one table for route monitoring. Each
	// of these subscriptions will have a different stream on which the routes
	// will be streamed.
	// Clients can also change subscription parameters for the table. In this
	// case the parameter will be re-applied for the table and the resulting
	// routes of the table are streamed. E.g. If policy is added to the
	// subscription to notify only static routes, then all non static routes
	// that were sent before are re-sent with a delete subscription operation.
	// Subsequent subscription messages for the table will contain only static
	// routes.
	// For the above case, streaming will happen on the new stream created for
	// the fresh Subscribe request sent. Streaming of routes on the old stream
	// will stop.
	// The response is sent as stream and will be sent as long as
	// subscription is valid. Once the subscription is deleted,
	// then this streaming will be stopped.
	RouteSubscribe(ctx context.Context, in *RouteSubscribeRequest, opts ...grpc.CallOption) (Rib_RouteSubscribeClient, error)
}

type ribClient struct {
	cc grpc.ClientConnInterface
}

func NewRibClient(cc grpc.ClientConnInterface) RibClient {
	return &ribClient{cc}
}

func (c *ribClient) RouteInitialize(ctx context.Context, in *RouteInitializeRequest, opts ...grpc.CallOption) (*RouteInitializeResponse, error) {
	out := new(RouteInitializeResponse)
	err := c.cc.Invoke(ctx, "/jnx.jet.routing.rib.Rib/RouteInitialize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ribClient) RouteCleanup(ctx context.Context, in *RouteCleanupRequest, opts ...grpc.CallOption) (*RouteCleanupResponse, error) {
	out := new(RouteCleanupResponse)
	err := c.cc.Invoke(ctx, "/jnx.jet.routing.rib.Rib/RouteCleanup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ribClient) RouteAdd(ctx context.Context, in *RouteUpdateRequest, opts ...grpc.CallOption) (*RouteSetOperResponse, error) {
	out := new(RouteSetOperResponse)
	err := c.cc.Invoke(ctx, "/jnx.jet.routing.rib.Rib/RouteAdd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ribClient) RouteModify(ctx context.Context, in *RouteUpdateRequest, opts ...grpc.CallOption) (*RouteSetOperResponse, error) {
	out := new(RouteSetOperResponse)
	err := c.cc.Invoke(ctx, "/jnx.jet.routing.rib.Rib/RouteModify", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ribClient) RouteUpdate(ctx context.Context, in *RouteUpdateRequest, opts ...grpc.CallOption) (*RouteSetOperResponse, error) {
	out := new(RouteSetOperResponse)
	err := c.cc.Invoke(ctx, "/jnx.jet.routing.rib.Rib/RouteUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ribClient) RouteDelete(ctx context.Context, in *RouteDeleteRequest, opts ...grpc.CallOption) (*RouteDeleteResponse, error) {
	out := new(RouteDeleteResponse)
	err := c.cc.Invoke(ctx, "/jnx.jet.routing.rib.Rib/RouteDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ribClient) RouteGet(ctx context.Context, in *RouteGetRequest, opts ...grpc.CallOption) (Rib_RouteGetClient, error) {
	stream, err := c.cc.NewStream(ctx, &Rib_ServiceDesc.Streams[0], "/jnx.jet.routing.rib.Rib/RouteGet", opts...)
	if err != nil {
		return nil, err
	}
	x := &ribRouteGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Rib_RouteGetClient interface {
	Recv() (*RouteGetResponse, error)
	grpc.ClientStream
}

type ribRouteGetClient struct {
	grpc.ClientStream
}

func (x *ribRouteGetClient) Recv() (*RouteGetResponse, error) {
	m := new(RouteGetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *ribClient) RouteSubscribe(ctx context.Context, in *RouteSubscribeRequest, opts ...grpc.CallOption) (Rib_RouteSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &Rib_ServiceDesc.Streams[1], "/jnx.jet.routing.rib.Rib/RouteSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &ribRouteSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Rib_RouteSubscribeClient interface {
	Recv() (*RouteSubscribeResponse, error)
	grpc.ClientStream
}

type ribRouteSubscribeClient struct {
	grpc.ClientStream
}

func (x *ribRouteSubscribeClient) Recv() (*RouteSubscribeResponse, error) {
	m := new(RouteSubscribeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RibServer is the server API for Rib service.
// All implementations must embed UnimplementedRibServer
// for forward compatibility
type RibServer interface {
	// [brief]: Route Initialization operation.
	// [detail]: Initializes the client with default preferences and
	// response address format.
	//
	// Route initialization is mandatory to be called before invoking
	// any other RIB API's.
	//
	// Route initialization request contains the default address format to be set
	// and default preference values.
	//
	// Initialization API can be called multiple times and the default parameters
	// will be updated with the latest values from the initialization
	// request.
	//
	// Route initialization API returns the status of the initialization along
	// with the detailed text message and the number of routes present in RIB owned by
	// previous sessions of the given client ID.
	RouteInitialize(context.Context, *RouteInitializeRequest) (*RouteInitializeResponse, error)
	// [brief]: Route clean up operation.
	// [detail]: RouteCleanup cleans all the routes added by the
	// particular client ID.
	// The API always returns the final status and the textual detailed message.
	RouteCleanup(context.Context, *RouteCleanupRequest) (*RouteCleanupResponse, error)
	// [brief]: Route Add operation
	// [detail]: Add a static route to the routing table.
	// RouteAdd may be called multiple times for the same prefix to add
	// multiple paths with distinct cookie for the same destination.
	// If a matching route already exists in the given table, then an error
	// will be returned.
	// RouteUpdateRequest may contain from one to 1000 routes to be added.
	// If the request contains multiple routes, the routes will
	// be processed in the order given and the first error encountered will
	// cause the request to abort.
	// The API always returns the final status (success or first error
	// encountered) and the number of routes that were successfully created
	// prior to any error or full completion of the request.
	RouteAdd(context.Context, *RouteUpdateRequest) (*RouteSetOperResponse, error)
	// [brief]: Route Modify operation
	// [detail]: Modify an existing programmed static route in the routing
	// table. For each route in the request, if the key is matched, the
	// matched route will be updated with the supplied route attributes.
	// If a matching route does not exist in the given table, then an error
	// will be returned.
	// RouteUpdateRequest may contain from one to 1000 routes to be modified.
	// If the request contains multiple routes, the routes will be processed
	// in the order given and the first error encountered will cause the
	// request to abort.
	// The API always returns the final status (success or first error
	// encountered) and the number of routes that were successfully modified
	// prior to any error or full completion of the request.
	RouteModify(context.Context, *RouteUpdateRequest) (*RouteSetOperResponse, error)
	// [brief]: Route Update operation
	// [detail]: Create a new static route if a matching route does not exist,
	// OR modify an existing static route if it is already present in the
	// routing table.
	// RouteUpdateRequest may contain from one to 1000 routes to be added.
	// If the request contains multiple routes, the routes will be processed
	// in the order given and the first error encountered will cause the
	// request to abort.
	// The API always returns the final status (success or first error
	//  encountered) and the number of routes that were successfully modified
	// prior to any error or full completion of the request.
	RouteUpdate(context.Context, *RouteUpdateRequest) (*RouteSetOperResponse, error)
	// [brief]: Route Delete operation
	// [detail]: Delete a static route from the routing table.
	// RouteDelete may be called multiple times for the same prefix
	// to delete multiple paths with distinct path_cookie for the same
	// destination. (NOTE: cookie support not yet implemented)
	// The request may contain from one to 1000 routes to be deleted.
	// If the request contains multiple routes, the routes will
	// be processed in the order given and the first error encountered will
	// cause the request to abort.
	// The API always returns the final status (success or first error
	// encountered) and the number of routes that were successfully modified
	// prior to any error or full completion of the request.
	RouteDelete(context.Context, *RouteDeleteRequest) (*RouteDeleteResponse, error)
	// [brief]: Route Get operation
	// [detail]: Lookup a route from the routing table.
	//  Match fields that are not specified or that
	//  may match more than one route (e.g. a less-specific destination
	//  prefix) may result in multiple routes being returned in the replies.
	//  Responses are bulked for performance and the client can specify
	//  maximum number of route entries that JUNOS can send in one response
	//  message using route_count field. JUNOS may choose to pack less
	//  number of entries than that client has specified.
	//  Multiple route entries matching a given route prefix
	//  may be be counted as one (if its last one in the response) and may
	//  result in exceeding the specified route count.
	//  Replies are streamed until all match routes have been sent. The
	//  client will receive a final null message once all routes have
	//  been received.
	//  The server's walk of search results is not atomic so route changes
	//  during streaming and consumption of replies may or may not be
	//  reflected in the results.
	RouteGet(*RouteGetRequest, Rib_RouteGetServer) error
	// [brief]: Subscribe for the route entries of a table.
	// [detail]: When clients subscribe for a table all routes that passes
	// policy are streamed to the client. After this the routes that get added
	// or changed or deleted are streamed.
	// Clients can subscribe to more than one table for route monitoring. Each
	// of these subscriptions will have a different stream on which the routes
	// will be streamed.
	// Clients can also change subscription parameters for the table. In this
	// case the parameter will be re-applied for the table and the resulting
	// routes of the table are streamed. E.g. If policy is added to the
	// subscription to notify only static routes, then all non static routes
	// that were sent before are re-sent with a delete subscription operation.
	// Subsequent subscription messages for the table will contain only static
	// routes.
	// For the above case, streaming will happen on the new stream created for
	// the fresh Subscribe request sent. Streaming of routes on the old stream
	// will stop.
	// The response is sent as stream and will be sent as long as
	// subscription is valid. Once the subscription is deleted,
	// then this streaming will be stopped.
	RouteSubscribe(*RouteSubscribeRequest, Rib_RouteSubscribeServer) error
	mustEmbedUnimplementedRibServer()
}

// UnimplementedRibServer must be embedded to have forward compatible implementations.
type UnimplementedRibServer struct {
}

func (UnimplementedRibServer) RouteInitialize(context.Context, *RouteInitializeRequest) (*RouteInitializeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteInitialize not implemented")
}
func (UnimplementedRibServer) RouteCleanup(context.Context, *RouteCleanupRequest) (*RouteCleanupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteCleanup not implemented")
}
func (UnimplementedRibServer) RouteAdd(context.Context, *RouteUpdateRequest) (*RouteSetOperResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteAdd not implemented")
}
func (UnimplementedRibServer) RouteModify(context.Context, *RouteUpdateRequest) (*RouteSetOperResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteModify not implemented")
}
func (UnimplementedRibServer) RouteUpdate(context.Context, *RouteUpdateRequest) (*RouteSetOperResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteUpdate not implemented")
}
func (UnimplementedRibServer) RouteDelete(context.Context, *RouteDeleteRequest) (*RouteDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RouteDelete not implemented")
}
func (UnimplementedRibServer) RouteGet(*RouteGetRequest, Rib_RouteGetServer) error {
	return status.Errorf(codes.Unimplemented, "method RouteGet not implemented")
}
func (UnimplementedRibServer) RouteSubscribe(*RouteSubscribeRequest, Rib_RouteSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method RouteSubscribe not implemented")
}
func (UnimplementedRibServer) mustEmbedUnimplementedRibServer() {}

// UnsafeRibServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RibServer will
// result in compilation errors.
type UnsafeRibServer interface {
	mustEmbedUnimplementedRibServer()
}

func RegisterRibServer(s grpc.ServiceRegistrar, srv RibServer) {
	s.RegisterService(&Rib_ServiceDesc, srv)
}

func _Rib_RouteInitialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteInitializeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RibServer).RouteInitialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jnx.jet.routing.rib.Rib/RouteInitialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RibServer).RouteInitialize(ctx, req.(*RouteInitializeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rib_RouteCleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteCleanupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RibServer).RouteCleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jnx.jet.routing.rib.Rib/RouteCleanup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RibServer).RouteCleanup(ctx, req.(*RouteCleanupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rib_RouteAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RibServer).RouteAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jnx.jet.routing.rib.Rib/RouteAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RibServer).RouteAdd(ctx, req.(*RouteUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rib_RouteModify_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RibServer).RouteModify(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jnx.jet.routing.rib.Rib/RouteModify",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RibServer).RouteModify(ctx, req.(*RouteUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rib_RouteUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RibServer).RouteUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jnx.jet.routing.rib.Rib/RouteUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RibServer).RouteUpdate(ctx, req.(*RouteUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rib_RouteDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RouteDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RibServer).RouteDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jnx.jet.routing.rib.Rib/RouteDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RibServer).RouteDelete(ctx, req.(*RouteDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rib_RouteGet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteGetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RibServer).RouteGet(m, &ribRouteGetServer{stream})
}

type Rib_RouteGetServer interface {
	Send(*RouteGetResponse) error
	grpc.ServerStream
}

type ribRouteGetServer struct {
	grpc.ServerStream
}

func (x *ribRouteGetServer) Send(m *RouteGetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Rib_RouteSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RouteSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RibServer).RouteSubscribe(m, &ribRouteSubscribeServer{stream})
}

type Rib_RouteSubscribeServer interface {
	Send(*RouteSubscribeResponse) error
	grpc.ServerStream
}

type ribRouteSubscribeServer struct {
	grpc.ServerStream
}

func (x *ribRouteSubscribeServer) Send(m *RouteSubscribeResponse) error {
	return x.ServerStream.SendMsg(m)
}

// Rib_ServiceDesc is the grpc.ServiceDesc for Rib service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Rib_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "jnx.jet.routing.rib.Rib",
	HandlerType: (*RibServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RouteInitialize",
			Handler:    _Rib_RouteInitialize_Handler,
		},
		{
			MethodName: "RouteCleanup",
			Handler:    _Rib_RouteCleanup_Handler,
		},
		{
			MethodName: "RouteAdd",
			Handler:    _Rib_RouteAdd_Handler,
		},
		{
			MethodName: "RouteModify",
			Handler:    _Rib_RouteModify_Handler,
		},
		{
			MethodName: "RouteUpdate",
			Handler:    _Rib_RouteUpdate_Handler,
		},
		{
			MethodName: "RouteDelete",
			Handler:    _Rib_RouteDelete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RouteGet",
			Handler:       _Rib_RouteGet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RouteSubscribe",
			Handler:       _Rib_RouteSubscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "jnx_routing_rib_service.proto",
}
