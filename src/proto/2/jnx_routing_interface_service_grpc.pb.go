// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// InterfacesClient is the client API for Interfaces service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InterfacesClient interface {
	// [brief]: Service initialize.
	// [detail]: A client must first use this RPC to initialize and connect
	// to the service, before issuing other RPCs.
	InterfaceInitialize(ctx context.Context, in *InterfaceInitializeRequest, opts ...grpc.CallOption) (*InterfaceInitializeResponse, error)
	// [brief]: Get a routing interface by name or index.
	// [detail]: A client may use this RPC to query an individual routing interface
	// at any time. The client should already know the name or index of
	// the interface via notification or any other method.
	InterfaceGet(ctx context.Context, in *InterfaceGetRequest, opts ...grpc.CallOption) (*InterfaceGetResponse, error)
	// [brief]: Notification Subscribe.
	// [detail]: Request to receive asynchronous notifications of
	// of routing interface CHANGED, UP, DOWN and DELETED
	// status events.
	// After a InterfaceSubscribeRequest,
	// an initial InterfaceSubscribeResponse is sent
	// immediately to the client, as a confirmation for the
	// request. This response may or may not carry an interface.
	//
	// Then, InterfaceSubscribeResponses are
	// sent to the client, as a full flash of all the interfaces.
	//
	// Subsequently, a InterfaceSubscribeResponse
	// will be sent to the client upon a CHANGED, UP, DOWN,
	// or DELETED status event of an interface.
	// Notification compression:
	// When a status event of an interface is pending for a client
	// to be notified of, a new status event happens.
	// As a net result, a single notification representing the
	// latest status and attributes of the interface is sent to
	// the client. This should only happen when consecutive events
	// happen with extremely small intervals. Examples:
	// [1] When a CHANGED event is pending, an UP/DOWN
	// event happens. Hence, an UP/DOWN notification
	// is sent.
	// [2] When a CHANGED/UP/DOWN event is pending, a DELETED
	// event happens. Hence, a DELETED notification
	// is sent.
	// [3] When an UP/DOWN event if pending, a CHANGED
	// event happens. Hence, only an UP/DOWN notification
	// is sent.
	InterfaceSubscribe(ctx context.Context, in *InterfaceSubscribeRequest, opts ...grpc.CallOption) (Interfaces_InterfaceSubscribeClient, error)
	// [brief]: Notification unsubscribe.
	// [detail]: Request to stop receiving notifications
	// of routing interface events.
	InterfaceUnsubscribe(ctx context.Context, in *InterfaceUnsubscribeRequest, opts ...grpc.CallOption) (*InterfaceUnsubscribeResponse, error)
	// [brief]: Notification refresh.
	// [detail]: Request to receive a refresh of notifications
	// of all routing interfaces, with their current status and attributes.
	InterfaceRefresh(ctx context.Context, in *InterfaceRefreshRequest, opts ...grpc.CallOption) (*InterfaceRefreshResponse, error)
}

type interfacesClient struct {
	cc grpc.ClientConnInterface
}

func NewInterfacesClient(cc grpc.ClientConnInterface) InterfacesClient {
	return &interfacesClient{cc}
}

func (c *interfacesClient) InterfaceInitialize(ctx context.Context, in *InterfaceInitializeRequest, opts ...grpc.CallOption) (*InterfaceInitializeResponse, error) {
	out := new(InterfaceInitializeResponse)
	err := c.cc.Invoke(ctx, "/jnx.jet.routing.interfaces.Interfaces/InterfaceInitialize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfacesClient) InterfaceGet(ctx context.Context, in *InterfaceGetRequest, opts ...grpc.CallOption) (*InterfaceGetResponse, error) {
	out := new(InterfaceGetResponse)
	err := c.cc.Invoke(ctx, "/jnx.jet.routing.interfaces.Interfaces/InterfaceGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfacesClient) InterfaceSubscribe(ctx context.Context, in *InterfaceSubscribeRequest, opts ...grpc.CallOption) (Interfaces_InterfaceSubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &Interfaces_ServiceDesc.Streams[0], "/jnx.jet.routing.interfaces.Interfaces/InterfaceSubscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &interfacesInterfaceSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Interfaces_InterfaceSubscribeClient interface {
	Recv() (*InterfaceSubscribeResponse, error)
	grpc.ClientStream
}

type interfacesInterfaceSubscribeClient struct {
	grpc.ClientStream
}

func (x *interfacesInterfaceSubscribeClient) Recv() (*InterfaceSubscribeResponse, error) {
	m := new(InterfaceSubscribeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *interfacesClient) InterfaceUnsubscribe(ctx context.Context, in *InterfaceUnsubscribeRequest, opts ...grpc.CallOption) (*InterfaceUnsubscribeResponse, error) {
	out := new(InterfaceUnsubscribeResponse)
	err := c.cc.Invoke(ctx, "/jnx.jet.routing.interfaces.Interfaces/InterfaceUnsubscribe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interfacesClient) InterfaceRefresh(ctx context.Context, in *InterfaceRefreshRequest, opts ...grpc.CallOption) (*InterfaceRefreshResponse, error) {
	out := new(InterfaceRefreshResponse)
	err := c.cc.Invoke(ctx, "/jnx.jet.routing.interfaces.Interfaces/InterfaceRefresh", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InterfacesServer is the server API for Interfaces service.
// All implementations must embed UnimplementedInterfacesServer
// for forward compatibility
type InterfacesServer interface {
	// [brief]: Service initialize.
	// [detail]: A client must first use this RPC to initialize and connect
	// to the service, before issuing other RPCs.
	InterfaceInitialize(context.Context, *InterfaceInitializeRequest) (*InterfaceInitializeResponse, error)
	// [brief]: Get a routing interface by name or index.
	// [detail]: A client may use this RPC to query an individual routing interface
	// at any time. The client should already know the name or index of
	// the interface via notification or any other method.
	InterfaceGet(context.Context, *InterfaceGetRequest) (*InterfaceGetResponse, error)
	// [brief]: Notification Subscribe.
	// [detail]: Request to receive asynchronous notifications of
	// of routing interface CHANGED, UP, DOWN and DELETED
	// status events.
	// After a InterfaceSubscribeRequest,
	// an initial InterfaceSubscribeResponse is sent
	// immediately to the client, as a confirmation for the
	// request. This response may or may not carry an interface.
	//
	// Then, InterfaceSubscribeResponses are
	// sent to the client, as a full flash of all the interfaces.
	//
	// Subsequently, a InterfaceSubscribeResponse
	// will be sent to the client upon a CHANGED, UP, DOWN,
	// or DELETED status event of an interface.
	// Notification compression:
	// When a status event of an interface is pending for a client
	// to be notified of, a new status event happens.
	// As a net result, a single notification representing the
	// latest status and attributes of the interface is sent to
	// the client. This should only happen when consecutive events
	// happen with extremely small intervals. Examples:
	// [1] When a CHANGED event is pending, an UP/DOWN
	// event happens. Hence, an UP/DOWN notification
	// is sent.
	// [2] When a CHANGED/UP/DOWN event is pending, a DELETED
	// event happens. Hence, a DELETED notification
	// is sent.
	// [3] When an UP/DOWN event if pending, a CHANGED
	// event happens. Hence, only an UP/DOWN notification
	// is sent.
	InterfaceSubscribe(*InterfaceSubscribeRequest, Interfaces_InterfaceSubscribeServer) error
	// [brief]: Notification unsubscribe.
	// [detail]: Request to stop receiving notifications
	// of routing interface events.
	InterfaceUnsubscribe(context.Context, *InterfaceUnsubscribeRequest) (*InterfaceUnsubscribeResponse, error)
	// [brief]: Notification refresh.
	// [detail]: Request to receive a refresh of notifications
	// of all routing interfaces, with their current status and attributes.
	InterfaceRefresh(context.Context, *InterfaceRefreshRequest) (*InterfaceRefreshResponse, error)
	mustEmbedUnimplementedInterfacesServer()
}

// UnimplementedInterfacesServer must be embedded to have forward compatible implementations.
type UnimplementedInterfacesServer struct {
}

func (UnimplementedInterfacesServer) InterfaceInitialize(context.Context, *InterfaceInitializeRequest) (*InterfaceInitializeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceInitialize not implemented")
}
func (UnimplementedInterfacesServer) InterfaceGet(context.Context, *InterfaceGetRequest) (*InterfaceGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceGet not implemented")
}
func (UnimplementedInterfacesServer) InterfaceSubscribe(*InterfaceSubscribeRequest, Interfaces_InterfaceSubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method InterfaceSubscribe not implemented")
}
func (UnimplementedInterfacesServer) InterfaceUnsubscribe(context.Context, *InterfaceUnsubscribeRequest) (*InterfaceUnsubscribeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceUnsubscribe not implemented")
}
func (UnimplementedInterfacesServer) InterfaceRefresh(context.Context, *InterfaceRefreshRequest) (*InterfaceRefreshResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InterfaceRefresh not implemented")
}
func (UnimplementedInterfacesServer) mustEmbedUnimplementedInterfacesServer() {}

// UnsafeInterfacesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InterfacesServer will
// result in compilation errors.
type UnsafeInterfacesServer interface {
	mustEmbedUnimplementedInterfacesServer()
}

func RegisterInterfacesServer(s grpc.ServiceRegistrar, srv InterfacesServer) {
	s.RegisterService(&Interfaces_ServiceDesc, srv)
}

func _Interfaces_InterfaceInitialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceInitializeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfacesServer).InterfaceInitialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jnx.jet.routing.interfaces.Interfaces/InterfaceInitialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfacesServer).InterfaceInitialize(ctx, req.(*InterfaceInitializeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Interfaces_InterfaceGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceGetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfacesServer).InterfaceGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jnx.jet.routing.interfaces.Interfaces/InterfaceGet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfacesServer).InterfaceGet(ctx, req.(*InterfaceGetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Interfaces_InterfaceSubscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InterfaceSubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InterfacesServer).InterfaceSubscribe(m, &interfacesInterfaceSubscribeServer{stream})
}

type Interfaces_InterfaceSubscribeServer interface {
	Send(*InterfaceSubscribeResponse) error
	grpc.ServerStream
}

type interfacesInterfaceSubscribeServer struct {
	grpc.ServerStream
}

func (x *interfacesInterfaceSubscribeServer) Send(m *InterfaceSubscribeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Interfaces_InterfaceUnsubscribe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceUnsubscribeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfacesServer).InterfaceUnsubscribe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jnx.jet.routing.interfaces.Interfaces/InterfaceUnsubscribe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfacesServer).InterfaceUnsubscribe(ctx, req.(*InterfaceUnsubscribeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Interfaces_InterfaceRefresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InterfaceRefreshRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterfacesServer).InterfaceRefresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/jnx.jet.routing.interfaces.Interfaces/InterfaceRefresh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterfacesServer).InterfaceRefresh(ctx, req.(*InterfaceRefreshRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Interfaces_ServiceDesc is the grpc.ServiceDesc for Interfaces service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Interfaces_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "jnx.jet.routing.interfaces.Interfaces",
	HandlerType: (*InterfacesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InterfaceInitialize",
			Handler:    _Interfaces_InterfaceInitialize_Handler,
		},
		{
			MethodName: "InterfaceGet",
			Handler:    _Interfaces_InterfaceGet_Handler,
		},
		{
			MethodName: "InterfaceUnsubscribe",
			Handler:    _Interfaces_InterfaceUnsubscribe_Handler,
		},
		{
			MethodName: "InterfaceRefresh",
			Handler:    _Interfaces_InterfaceRefresh_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "InterfaceSubscribe",
			Handler:       _Interfaces_InterfaceSubscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "jnx_routing_interface_service.proto",
}
